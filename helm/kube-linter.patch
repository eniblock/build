diff --git a/docs/generated/checks.md b/docs/generated/checks.md
index 7264adb..39cb477 100644
--- a/docs/generated/checks.md
+++ b/docs/generated/checks.md
@@ -370,6 +370,22 @@ KubeLinter includes the following built-in checks:
 {}
 ```
 
+## non-isolated-pod
+
+**Enabled by default**: No
+
+**Description**: Alert on deployment-like objects that are not selected by any networkpolicy.
+
+**Remediation**: Ensure pod does not accept unsafe traffic by isolating it with a networkpolicy object.
+
+**Template**: [non-isolated-pod](generated/templates.md#non-isolated-pods)
+
+**Parameters**:
+
+```json
+{}
+```
+
 ## privilege-escalation-container
 
 **Enabled by default**: Yes
diff --git a/docs/generated/templates.md b/docs/generated/templates.md
index bac02f0..f5d391e 100644
--- a/docs/generated/templates.md
+++ b/docs/generated/templates.md
@@ -464,6 +464,20 @@ KubeLinter supports the following templates:
 []
 ```
 
+## Non Isolated Pods
+
+**Key**: `non-isolated-pod`
+
+**Description**: Flag Pod that is not selected by any networkPolicy
+
+**Supported Objects**: NetworkPolicy
+
+**Parameters**:
+
+```json
+[]
+```
+
 ## Ports
 
 **Key**: `ports`
diff --git a/pkg/builtinchecks/yamls/non-isolated-pod.yaml b/pkg/builtinchecks/yamls/non-isolated-pod.yaml
new file mode 100644
index 0000000..28bf8fd
--- /dev/null
+++ b/pkg/builtinchecks/yamls/non-isolated-pod.yaml
@@ -0,0 +1,7 @@
+name: "non-isolated-pod"
+description: "Alert on deployment-like objects that are not selected by any networkpolicy."
+remediation: "Ensure pod does not accept unsafe traffic by isolating it with a networkpolicy object."
+scope:
+  objectKinds:
+    - DeploymentLike
+template: "non-isolated-pod"
\ No newline at end of file
diff --git a/pkg/lintcontext/mocks/networkpolicy.go b/pkg/lintcontext/mocks/networkpolicy.go
new file mode 100644
index 0000000..67c58fd
--- /dev/null
+++ b/pkg/lintcontext/mocks/networkpolicy.go
@@ -0,0 +1,30 @@
+package mocks
+
+import (
+	"testing"
+
+	"github.com/stretchr/testify/require"
+	"golang.stackrox.io/kube-linter/pkg/objectkinds"
+	networkingV1 "k8s.io/api/networking/v1"
+	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+// AddMockNetworkPolicy  adds a mock NetworkPolicy to LintContext
+func (l *MockLintContext) AddMockNetworkPolicy(t *testing.T, name string) {
+	require.NotEmpty(t, name)
+	l.objects[name] = &networkingV1.NetworkPolicy{
+		TypeMeta: metaV1.TypeMeta{
+			Kind:       objectkinds.NetworkPolicy,
+			APIVersion: objectkinds.GetNetworkPolicyAPIVersion(),
+		},
+		ObjectMeta: metaV1.ObjectMeta{Name: name},
+		Spec:       networkingV1.NetworkPolicySpec{},
+	}
+}
+
+//ModifyNetworkPolicy modifies a given networkpolicy in the context via the passed function.
+func (l *MockLintContext) ModifyNetworkPolicy(t *testing.T, name string, f func(networkpolicy *networkingV1.NetworkPolicy)) {
+	r, ok := l.objects[name].(*networkingV1.NetworkPolicy)
+	require.True(t, ok)
+	f(r)
+}
diff --git a/pkg/objectkinds/networkpolicy.go b/pkg/objectkinds/networkpolicy.go
new file mode 100644
index 0000000..614961e
--- /dev/null
+++ b/pkg/objectkinds/networkpolicy.go
@@ -0,0 +1,26 @@
+package objectkinds
+
+import (
+	v1 "k8s.io/api/networking/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+)
+
+const (
+	// NetworkPolicy represents Kubernetes NetworkPolicy objects.
+	NetworkPolicy = "NetworkPolicy"
+)
+
+var (
+	networkpolicyGVK = v1.SchemeGroupVersion.WithKind("NetworkPolicy")
+)
+
+func init() {
+	registerObjectKind(NetworkPolicy, matcherFunc(func(gvk schema.GroupVersionKind) bool {
+		return gvk == networkpolicyGVK
+	}))
+}
+
+//GetNetworkPolicyAPIVersion returns networkpolicy's apiversion
+func GetNetworkPolicyAPIVersion() string {
+	return networkpolicyGVK.GroupVersion().String()
+}
diff --git a/pkg/templates/all/all.go b/pkg/templates/all/all.go
index 07bb02f..dfb3656 100644
--- a/pkg/templates/all/all.go
+++ b/pkg/templates/all/all.go
@@ -22,6 +22,7 @@ import (
 	_ "golang.stackrox.io/kube-linter/pkg/templates/mismatchingselector"
 	_ "golang.stackrox.io/kube-linter/pkg/templates/namespace"
 	_ "golang.stackrox.io/kube-linter/pkg/templates/nonexistentserviceaccount"
+	_ "golang.stackrox.io/kube-linter/pkg/templates/nonisolatedpod"
 	_ "golang.stackrox.io/kube-linter/pkg/templates/ports"
 	_ "golang.stackrox.io/kube-linter/pkg/templates/privileged"
 	_ "golang.stackrox.io/kube-linter/pkg/templates/privilegedports"
diff --git a/pkg/templates/nonisolatedpod/internal/params/gen-params.go b/pkg/templates/nonisolatedpod/internal/params/gen-params.go
new file mode 100644
index 0000000..21bb3aa
--- /dev/null
+++ b/pkg/templates/nonisolatedpod/internal/params/gen-params.go
@@ -0,0 +1,52 @@
+// Code generated by kube-linter template codegen. DO NOT EDIT.
+// +build !templatecodegen
+
+package params
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/pkg/errors"
+	"golang.stackrox.io/kube-linter/pkg/check"
+	"golang.stackrox.io/kube-linter/pkg/templates/util"
+)
+
+var (
+	// Use some imports in case they don't get used otherwise.
+	_ = util.MustParseParameterDesc
+	_ = fmt.Sprintf
+
+	ParamDescs = []check.ParameterDesc{
+	}
+)
+
+func (p *Params) Validate() error {
+	var validationErrors []string
+	if len(validationErrors) > 0 {
+		return errors.Errorf("invalid parameters: %s", strings.Join(validationErrors, ", "))
+    }
+	return nil
+}
+
+// ParseAndValidate instantiates a Params object out of the passed map[string]interface{},
+// validates it, and returns it.
+// The return type is interface{} to satisfy the type in the Template struct.
+func ParseAndValidate(m map[string]interface{}) (interface{}, error) {
+	var p Params
+	if err := util.DecodeMapStructure(m, &p); err != nil {
+		return nil, err
+	}
+	if err := p.Validate(); err != nil {
+		return nil, err
+	}
+	return p, nil
+}
+
+// WrapInstantiateFunc is a convenience wrapper that wraps an untyped instantiate function
+// into a typed one.
+func WrapInstantiateFunc(f func(p Params) (check.Func, error)) func (interface{}) (check.Func, error) {
+	return func(paramsInt interface{}) (check.Func, error) {
+		return f(paramsInt.(Params))
+	}
+}
diff --git a/pkg/templates/nonisolatedpod/internal/params/params.go b/pkg/templates/nonisolatedpod/internal/params/params.go
new file mode 100644
index 0000000..578cc3a
--- /dev/null
+++ b/pkg/templates/nonisolatedpod/internal/params/params.go
@@ -0,0 +1,5 @@
+package params
+
+// Params represents the params accepted by this template.
+type Params struct {
+}
diff --git a/pkg/templates/nonisolatedpod/template.go b/pkg/templates/nonisolatedpod/template.go
new file mode 100644
index 0000000..1e60989
--- /dev/null
+++ b/pkg/templates/nonisolatedpod/template.go
@@ -0,0 +1,66 @@
+package nonisolatedpod
+
+import (
+	"fmt"
+
+	"golang.stackrox.io/kube-linter/pkg/check"
+	"golang.stackrox.io/kube-linter/pkg/config"
+	"golang.stackrox.io/kube-linter/pkg/diagnostic"
+	"golang.stackrox.io/kube-linter/pkg/extract"
+	"golang.stackrox.io/kube-linter/pkg/lintcontext"
+	"golang.stackrox.io/kube-linter/pkg/objectkinds"
+	"golang.stackrox.io/kube-linter/pkg/templates"
+	"golang.stackrox.io/kube-linter/pkg/templates/nonisolatedpod/internal/params"
+	networkingV1 "k8s.io/api/networking/v1"
+	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/labels"
+)
+
+const (
+	templateKey = "non-isolated-pod"
+)
+
+func init() {
+	templates.Register(check.Template{
+		HumanName:   "Non Isolated Pods",
+		Key:         templateKey,
+		Description: "Flag Pod that is not selected by any networkPolicy",
+		SupportedObjectKinds: config.ObjectKindsDesc{
+			ObjectKinds: []string{objectkinds.NetworkPolicy},
+		},
+		Parameters:             params.ParamDescs,
+		ParseAndValidateParams: params.ParseAndValidate,
+		Instantiate: params.WrapInstantiateFunc(func(_ params.Params) (check.Func, error) {
+			return func(lintCtx lintcontext.LintContext, object lintcontext.Object) []diagnostic.Diagnostic {
+				podTemplateSpec, found := extract.PodTemplateSpec(object.K8sObject)
+				if !found {
+					return nil
+				}
+				for _, obj := range lintCtx.Objects() {
+					networkpolicy, ok := obj.K8sObject.(*networkingV1.NetworkPolicy)
+					if !ok {
+						continue
+					}
+					if object.K8sObject.GetNamespace() != obj.K8sObject.GetNamespace() {
+						continue
+					}
+					podselector := networkpolicy.Spec.PodSelector
+					labelSelector, err := metaV1.LabelSelectorAsSelector(&metaV1.LabelSelector{MatchLabels: podselector.MatchLabels,
+						MatchExpressions: podselector.MatchExpressions})
+					if err != nil {
+						return []diagnostic.Diagnostic{{
+							Message: fmt.Sprintf("networkpolicy has invalid podSelector: %v", err),
+						}}
+					}
+					if labelSelector.Matches(labels.Set(podTemplateSpec.Labels)) {
+						// Found!
+						return nil
+					}
+				}
+				return []diagnostic.Diagnostic{{
+					Message: "pods created by this object are non-isolated",
+				}}
+			}, nil
+		}),
+	})
+}
diff --git a/pkg/templates/nonisolatedpod/template_test.go b/pkg/templates/nonisolatedpod/template_test.go
new file mode 100644
index 0000000..f1da275
--- /dev/null
+++ b/pkg/templates/nonisolatedpod/template_test.go
@@ -0,0 +1,136 @@
+package nonisolatedpod
+
+import (
+	"testing"
+
+	"github.com/stretchr/testify/suite"
+	"golang.stackrox.io/kube-linter/pkg/diagnostic"
+	"golang.stackrox.io/kube-linter/pkg/lintcontext/mocks"
+	"golang.stackrox.io/kube-linter/pkg/templates"
+	"golang.stackrox.io/kube-linter/pkg/templates/nonisolatedpod/internal/params"
+
+	appsV1 "k8s.io/api/apps/v1"
+	networkingV1 "k8s.io/api/networking/v1"
+	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+const (
+	pod1             = "pod1"
+	pod2             = "pod2"
+	networkpolicyall = "networkpolicy-isolating-all"
+	networkpolicy1   = "networkpolicy-isolating-pod1"
+	networkpolicy2   = "networkpolicy-isolating-pod2"
+	networkpolicy3   = "networkpolicy-isolating-none"
+)
+
+var emptyLabelSelector = metaV1.LabelSelector{} //empty selector
+
+var labelselector1 = metaV1.LabelSelector{
+	MatchLabels: map[string]string{"app": "pod1-test"},
+}
+
+var labelselector2 = metaV1.LabelSelector{
+	MatchLabels: map[string]string{"app": "pod2-test"},
+}
+
+var labelselector3 = metaV1.LabelSelector{
+	MatchLabels: map[string]string{"app": "no-pods-test"},
+}
+
+func TestNonIsolatedPod(t *testing.T) {
+	suite.Run(t, new(NonIsolatedPodTestSuite))
+}
+
+type NonIsolatedPodTestSuite struct {
+	templates.TemplateTestSuite
+
+	ctx *mocks.MockLintContext
+}
+
+func (s *NonIsolatedPodTestSuite) SetupTest() {
+	s.Init(templateKey)
+	s.ctx = mocks.NewMockContext()
+}
+
+func (s *NonIsolatedPodTestSuite) AddNetworkPolicy(name string, podSelector metaV1.LabelSelector) {
+	s.ctx.AddMockNetworkPolicy(s.T(), name)
+	s.ctx.ModifyNetworkPolicy(s.T(), name, func(networkpolicy *networkingV1.NetworkPolicy) {
+		networkpolicy.Spec.PodSelector = podSelector
+	})
+}
+
+func (s *NonIsolatedPodTestSuite) AddDeploymentWithLabels(name string, labels *metaV1.LabelSelector) {
+	s.ctx.AddMockDeployment(s.T(), name)
+	s.ctx.ModifyDeployment(s.T(), name, func(deployment *appsV1.Deployment) {
+		deployment.Spec.Template.Labels = labels.MatchLabels
+	})
+}
+
+func (s *NonIsolatedPodTestSuite) TestAllPodsIsolatedWithNetworkPolicyEmptySelector() {
+	s.AddDeploymentWithLabels(pod1, &labelselector1)
+	s.AddDeploymentWithLabels(pod2, &labelselector2)
+	s.AddNetworkPolicy(networkpolicyall, emptyLabelSelector)
+
+	s.Validate(s.ctx, []templates.TestCase{
+		{
+			Param: params.Params{},
+			Diagnostics: map[string][]diagnostic.Diagnostic{
+				pod1: {},
+				pod2: {},
+			},
+			ExpectInstantiationError: false,
+		},
+	})
+}
+
+func (s *NonIsolatedPodTestSuite) TestAllPodsIsolatedWithMultipleNetworkPolicies() {
+	s.AddDeploymentWithLabels(pod1, &labelselector1)
+	s.AddDeploymentWithLabels(pod2, &labelselector2)
+	s.AddNetworkPolicy(networkpolicy1, labelselector1)
+	s.AddNetworkPolicy(networkpolicy2, labelselector2)
+
+	s.Validate(s.ctx, []templates.TestCase{
+		{
+			Param: params.Params{},
+			Diagnostics: map[string][]diagnostic.Diagnostic{
+				pod1: {},
+				pod2: {},
+			},
+			ExpectInstantiationError: false,
+		},
+	})
+}
+
+func (s *NonIsolatedPodTestSuite) TestSomePodsIsolated() {
+	s.AddDeploymentWithLabels(pod1, &labelselector1)
+	s.AddDeploymentWithLabels(pod2, &labelselector2)
+	s.AddNetworkPolicy(networkpolicy2, labelselector2)
+
+	s.Validate(s.ctx, []templates.TestCase{
+		{
+			Param: params.Params{},
+			Diagnostics: map[string][]diagnostic.Diagnostic{
+				pod1: {{Message: "pods created by this object are non-isolated"}},
+				pod2: {},
+			},
+			ExpectInstantiationError: false,
+		},
+	})
+}
+
+func (s *NonIsolatedPodTestSuite) TestAllPodsNonIsolated() {
+	s.AddDeploymentWithLabels(pod1, &labelselector1)
+	s.AddDeploymentWithLabels(pod2, &labelselector2)
+	s.AddNetworkPolicy(networkpolicy3, labelselector3)
+
+	s.Validate(s.ctx, []templates.TestCase{
+		{
+			Param: params.Params{},
+			Diagnostics: map[string][]diagnostic.Diagnostic{
+				pod1: {{Message: "pods created by this object are non-isolated"}},
+				pod2: {{Message: "pods created by this object are non-isolated"}},
+			},
+			ExpectInstantiationError: false,
+		},
+	})
+}
